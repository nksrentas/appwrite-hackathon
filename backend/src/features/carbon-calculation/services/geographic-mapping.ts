import { parse } from 'csv-parse';\nimport axios from 'axios';\nimport * as cron from 'node-cron';\nimport { logger } from '@shared/utils/logger';\nimport { CacheService } from '@shared/utils/cache';\n\ninterface PostalCodeMapping {\n  postalCode: string;\n  normalizedCode: string;\n  country: string;\n  region: string;\n  state?: string;\n  province?: string;\n  eGridSubregion?: string;\n  electricityZone: string;\n  coordinates?: {\n    latitude: number;\n    longitude: number;\n  };\n  timezone?: string;\n  lastUpdated: string;\n}\n\ninterface GeographicBoundary {\n  id: string;\n  name: string;\n  type: 'country' | 'state' | 'province' | 'region' | 'subregion';\n  parentId?: string;\n  coordinates: {\n    latitude: number;\n    longitude: number;\n  };\n  bounds: {\n    north: number;\n    south: number;\n    east: number;\n    west: number;\n  };\n  emissionZone: string;\n}\n\ninterface MappingStatistics {\n  totalMappings: number;\n  countriesSupported: number;\n  lastUpdate: string;\n  coveragePercentage: number;\n  dataQuality: {\n    complete: number;\n    partial: number;\n    missing: number;\n  };\n}\n\nclass GeographicMappingService {\n  private cache: CacheService;\n  private postalMappings: Map<string, PostalCodeMapping> = new Map();\n  private boundaries: Map<string, GeographicBoundary> = new Map();\n  private countryMappings: Map<string, string[]> = new Map();\n  private statistics: MappingStatistics;\n\n  constructor() {\n    this.cache = new CacheService();\n    this.statistics = {\n      totalMappings: 0,\n      countriesSupported: 0,\n      lastUpdate: new Date().toISOString(),\n      coveragePercentage: 0,\n      dataQuality: {\n        complete: 0,\n        partial: 0,\n        missing: 0\n      }\n    };\n\n    this.initializeDataSources();\n    this.initializeUpdateScheduler();\n  }\n\n  private async initializeDataSources(): Promise<void> {\n    try {\n      const cachedMappings = await this.cache.get('geographic_mappings');\n      if (cachedMappings && this.isCacheValid(cachedMappings)) {\n        this.loadFromCache(cachedMappings);\n        logger.info('Geographic mappings loaded from cache', {\n          totalMappings: this.postalMappings.size,\n          countries: this.countryMappings.size\n        });\n      } else {\n        await this.loadAllMappings();\n      }\n    } catch (error: any) {\n      logger.error('Failed to initialize geographic mappings', {\n        error: error.message\n      });\n      this.loadFallbackMappings();\n    }\n  }\n\n  private isCacheValid(cachedData: any): boolean {\n    if (!cachedData || !cachedData.lastUpdate) return false;\n    \n    const cacheAge = Date.now() - new Date(cachedData.lastUpdate).getTime();\n    const maxAge = 7 * 24 * 60 * 60 * 1000; // 1 week\n    \n    return cacheAge < maxAge;\n  }\n\n  private loadFromCache(cachedData: any): void {\n    this.postalMappings = new Map(Object.entries(cachedData.postalMappings || {}));\n    this.boundaries = new Map(Object.entries(cachedData.boundaries || {}));\n    this.countryMappings = new Map(Object.entries(cachedData.countryMappings || {}));\n    this.statistics = cachedData.statistics || this.statistics;\n  }\n\n  private async loadAllMappings(): Promise<void> {\n    const startTime = Date.now();\n    \n    try {\n      logger.info('Loading geographic mappings from external sources');\n      \n      await Promise.all([\n        this.loadUSPostalMappings(),\n        this.loadInternationalMappings(),\n        this.loadEGridSubregions(),\n        this.loadElectricityZones()\n      ]);\n      \n      await this.generateStatistics();\n      await this.cacheAllMappings();\n      \n      const duration = Date.now() - startTime;\n      logger.info('Geographic mappings loaded successfully', {\n        totalMappings: this.postalMappings.size,\n        countries: this.countryMappings.size,\n        duration: `${duration}ms`\n      });\n      \n    } catch (error: any) {\n      logger.error('Failed to load geographic mappings', {\n        error: error.message\n      });\n      this.loadFallbackMappings();\n    }\n  }\n\n  private async loadUSPostalMappings(): Promise<void> {\n    try {\n      const zipToGridUrl = 'https://www.epa.gov/sites/default/files/2023-01/power-profiler-zipcode-tool-2022.csv';\n      \n      const response = await axios.get(zipToGridUrl, {\n        responseType: 'stream',\n        timeout: 30000,\n        headers: {\n          'User-Agent': 'EcoTrace-Geographic-Mapper/1.0'\n        }\n      });\n\n      const mappings: PostalCodeMapping[] = [];\n      \n      return new Promise((resolve, reject) => {\n        response.data\n          .pipe(parse({ \n            columns: true,\n            skip_empty_lines: true,\n            trim: true\n          }))\n          .on('data', (row: any) => {\n            if (row['ZIP'] && row['eGRID subregion acronym']) {\n              const zipCode = row['ZIP'].toString().padStart(5, '0');\n              const mapping: PostalCodeMapping = {\n                postalCode: zipCode,\n                normalizedCode: this.normalizePostalCode(zipCode, 'US'),\n                country: 'US',\n                region: row['State abbreviation'] || '',\n                state: row['State abbreviation'] || '',\n                eGridSubregion: row['eGRID subregion acronym'],\n                electricityZone: `US-${row['State abbreviation'] || 'US'}`,\n                lastUpdated: new Date().toISOString()\n              };\n              \n              mappings.push(mapping);\n            }\n          })\n          .on('end', () => {\n            mappings.forEach(mapping => {\n              this.postalMappings.set(mapping.normalizedCode, mapping);\n            });\n            \n            this.updateCountryMappings('US', mappings.map(m => m.normalizedCode));\n            \n            logger.info('US postal mappings loaded', {\n              zipCodeCount: mappings.length\n            });\n            resolve();\n          })\n          .on('error', reject);\n      });\n      \n    } catch (error: any) {\n      logger.warn('Failed to load US postal mappings from EPA, using fallback', {\n        error: error.message\n      });\n      this.loadUSFallbackMappings();\n    }\n  }\n\n  private async loadInternationalMappings(): Promise<void> {\n    const countries = [\n      { code: 'CA', name: 'Canada', zones: ['CA-AB', 'CA-BC', 'CA-MB', 'CA-NB', 'CA-NL', 'CA-NS', 'CA-NT', 'CA-NU', 'CA-ON', 'CA-PE', 'CA-QC', 'CA-SK', 'CA-YT'] },\n      { code: 'GB', name: 'United Kingdom', zones: ['GB'] },\n      { code: 'DE', name: 'Germany', zones: ['DE'] },\n      { code: 'FR', name: 'France', zones: ['FR'] },\n      { code: 'JP', name: 'Japan', zones: ['JP'] },\n      { code: 'AU', name: 'Australia', zones: ['AU-NSW', 'AU-QLD', 'AU-SA', 'AU-TAS', 'AU-VIC', 'AU-WA'] },\n      { code: 'CN', name: 'China', zones: ['CN'] },\n      { code: 'IN', name: 'India', zones: ['IN'] },\n      { code: 'BR', name: 'Brazil', zones: ['BR-S', 'BR-NE', 'BR-N', 'BR-CS'] }\n    ];\n\n    for (const country of countries) {\n      await this.loadCountryPostalMappings(country.code, country.name, country.zones);\n    }\n  }\n\n  private async loadCountryPostalMappings(countryCode: string, countryName: string, zones: string[]): Promise<void> {\n    const postalRanges = this.getPostalRangesForCountry(countryCode);\n    const mappings: PostalCodeMapping[] = [];\n    \n    postalRanges.forEach(range => {\n      const zone = zones.find(z => z.includes(range.region)) || zones[0];\n      \n      for (let i = range.start; i <= range.end; i += range.increment) {\n        const postalCode = this.formatPostalCode(i, countryCode);\n        const normalizedCode = this.normalizePostalCode(postalCode, countryCode);\n        \n        const mapping: PostalCodeMapping = {\n          postalCode,\n          normalizedCode,\n          country: countryCode,\n          region: range.region,\n          electricityZone: zone,\n          coordinates: range.coordinates ? {\n            latitude: range.coordinates.lat + (Math.random() - 0.5) * 2,\n            longitude: range.coordinates.lng + (Math.random() - 0.5) * 2\n          } : undefined,\n          timezone: range.timezone,\n          lastUpdated: new Date().toISOString()\n        };\n        \n        mappings.push(mapping);\n      }\n    });\n    \n    mappings.forEach(mapping => {\n      this.postalMappings.set(mapping.normalizedCode, mapping);\n    });\n    \n    this.updateCountryMappings(countryCode, mappings.map(m => m.normalizedCode));\n    \n    logger.debug(`Loaded postal mappings for ${countryName}`, {\n      mappingCount: mappings.length\n    });\n  }\n\n  private getPostalRangesForCountry(countryCode: string): Array<{\n    start: number;\n    end: number;\n    increment: number;\n    region: string;\n    coordinates?: { lat: number; lng: number };\n    timezone?: string;\n  }> {\n    const ranges: Record<string, Array<any>> = {\n      'CA': [\n        { start: 10000, end: 19999, increment: 1000, region: 'ON', coordinates: { lat: 43.65, lng: -79.38 }, timezone: 'America/Toronto' },\n        { start: 20000, end: 29999, increment: 1000, region: 'QC', coordinates: { lat: 45.50, lng: -73.57 }, timezone: 'America/Montreal' },\n        { start: 30000, end: 39999, increment: 1000, region: 'QC', coordinates: { lat: 46.81, lng: -71.21 }, timezone: 'America/Montreal' },\n        { start: 80000, end: 89999, increment: 1000, region: 'AB', coordinates: { lat: 51.05, lng: -114.07 }, timezone: 'America/Edmonton' },\n        { start: 90000, end: 99999, increment: 1000, region: 'BC', coordinates: { lat: 49.28, lng: -123.12 }, timezone: 'America/Vancouver' }\n      ],\n      'GB': [\n        { start: 10000, end: 99999, increment: 5000, region: 'EN', coordinates: { lat: 51.51, lng: -0.13 }, timezone: 'Europe/London' }\n      ],\n      'DE': [\n        { start: 10000, end: 99999, increment: 5000, region: 'DE', coordinates: { lat: 52.52, lng: 13.40 }, timezone: 'Europe/Berlin' }\n      ],\n      'FR': [\n        { start: 10000, end: 99999, increment: 5000, region: 'FR', coordinates: { lat: 48.86, lng: 2.35 }, timezone: 'Europe/Paris' }\n      ],\n      'JP': [\n        { start: 1000000, end: 9999999, increment: 50000, region: 'JP', coordinates: { lat: 35.68, lng: 139.69 }, timezone: 'Asia/Tokyo' }\n      ],\n      'AU': [\n        { start: 1000, end: 2999, increment: 100, region: 'NSW', coordinates: { lat: -33.87, lng: 151.21 }, timezone: 'Australia/Sydney' },\n        { start: 3000, end: 3999, increment: 100, region: 'VIC', coordinates: { lat: -37.81, lng: 144.96 }, timezone: 'Australia/Melbourne' },\n        { start: 4000, end: 4999, increment: 100, region: 'QLD', coordinates: { lat: -27.47, lng: 153.03 }, timezone: 'Australia/Brisbane' },\n        { start: 5000, end: 5999, increment: 100, region: 'SA', coordinates: { lat: -34.93, lng: 138.60 }, timezone: 'Australia/Adelaide' },\n        { start: 6000, end: 6999, increment: 100, region: 'WA', coordinates: { lat: -31.95, lng: 115.86 }, timezone: 'Australia/Perth' },\n        { start: 7000, end: 7999, increment: 100, region: 'TAS', coordinates: { lat: -42.88, lng: 147.33 }, timezone: 'Australia/Hobart' }\n      ],\n      'CN': [\n        { start: 100000, end: 999999, increment: 50000, region: 'CN', coordinates: { lat: 39.90, lng: 116.40 }, timezone: 'Asia/Shanghai' }\n      ],\n      'IN': [\n        { start: 100000, end: 999999, increment: 50000, region: 'IN', coordinates: { lat: 28.61, lng: 77.21 }, timezone: 'Asia/Kolkata' }\n      ],\n      'BR': [\n        { start: 10000, end: 99999, increment: 5000, region: 'BR', coordinates: { lat: -23.55, lng: -46.64 }, timezone: 'America/Sao_Paulo' }\n      ]\n    };\n    \n    return ranges[countryCode] || [];\n  }\n\n  private formatPostalCode(code: number, countryCode: string): string {\n    switch (countryCode) {\n      case 'US':\n        return code.toString().padStart(5, '0');\n      case 'CA':\n        const str = code.toString().padStart(6, '0');\n        return `${str.slice(0, 3)} ${str.slice(3)}`;\n      case 'GB':\n        return `${String.fromCharCode(65 + Math.floor(code / 10000))}${(code % 10000).toString().padStart(4, '0')}`;\n      case 'JP':\n        const jpStr = code.toString().padStart(7, '0');\n        return `${jpStr.slice(0, 3)}-${jpStr.slice(3)}`;\n      case 'AU':\n        return code.toString().padStart(4, '0');\n      default:\n        return code.toString().padStart(5, '0');\n    }\n  }\n\n  private normalizePostalCode(postalCode: string, countryCode: string): string {\n    let normalized = postalCode.replace(/\\s+/g, '').replace(/-/g, '').toUpperCase();\n    \n    switch (countryCode) {\n      case 'US':\n        return normalized.substring(0, 5);\n      case 'CA':\n        return normalized.substring(0, 6);\n      case 'GB':\n        return normalized.substring(0, 6);\n      case 'DE':\n      case 'FR':\n        return normalized.substring(0, 5);\n      case 'JP':\n        return normalized.substring(0, 7);\n      case 'AU':\n        return normalized.substring(0, 4);\n      default:\n        return normalized.substring(0, 8);\n    }\n  }\n\n  private async loadEGridSubregions(): Promise<void> {\n    const eGridSubregions = [\n      { id: 'CAMX', name: 'California ISO', bounds: { north: 42.0, south: 32.5, east: -114.1, west: -124.4 } },\n      { id: 'ERCT', name: 'ERCOT Texas', bounds: { north: 36.5, south: 25.8, east: -93.5, west: -106.6 } },\n      { id: 'NYCW', name: 'NYISO Zone A-E', bounds: { north: 45.0, south: 40.5, east: -71.9, west: -79.8 } },\n      { id: 'NYUP', name: 'NYISO Zone F-K', bounds: { north: 45.0, south: 42.0, east: -73.3, west: -79.8 } },\n      { id: 'NEWE', name: 'ISO New England', bounds: { north: 47.5, south: 40.9, east: -66.9, west: -73.7 } },\n      { id: 'RFCE', name: 'RFC East', bounds: { north: 42.5, south: 36.5, east: -75.0, west: -83.0 } },\n      { id: 'SRSO', name: 'SERC South', bounds: { north: 36.6, south: 24.5, east: -75.4, west: -91.7 } },\n      { id: 'FRCC', name: 'FRCC All', bounds: { north: 31.0, south: 24.4, east: -79.9, west: -87.6 } }\n    ];\n    \n    eGridSubregions.forEach(subregion => {\n      const boundary: GeographicBoundary = {\n        id: subregion.id,\n        name: subregion.name,\n        type: 'subregion',\n        coordinates: {\n          latitude: (subregion.bounds.north + subregion.bounds.south) / 2,\n          longitude: (subregion.bounds.east + subregion.bounds.west) / 2\n        },\n        bounds: subregion.bounds,\n        emissionZone: subregion.id\n      };\n      \n      this.boundaries.set(subregion.id, boundary);\n    });\n  }\n\n  private async loadElectricityZones(): Promise<void> {\n    const electricityZones = [\n      { id: 'US-CA', name: 'California', country: 'US', coordinates: { lat: 36.7783, lng: -119.4179 } },\n      { id: 'US-TX', name: 'Texas', country: 'US', coordinates: { lat: 31.9686, lng: -99.9018 } },\n      { id: 'US-NY', name: 'New York', country: 'US', coordinates: { lat: 42.1657, lng: -74.9481 } },\n      { id: 'GB', name: 'Great Britain', country: 'GB', coordinates: { lat: 55.3781, lng: -3.4360 } },\n      { id: 'DE', name: 'Germany', country: 'DE', coordinates: { lat: 51.1657, lng: 10.4515 } },\n      { id: 'FR', name: 'France', country: 'FR', coordinates: { lat: 46.2276, lng: 2.2137 } },\n      { id: 'JP', name: 'Japan', country: 'JP', coordinates: { lat: 36.2048, lng: 138.2529 } },\n      { id: 'AU', name: 'Australia', country: 'AU', coordinates: { lat: -25.2744, lng: 133.7751 } },\n      { id: 'CN', name: 'China', country: 'CN', coordinates: { lat: 35.8617, lng: 104.1954 } },\n      { id: 'IN', name: 'India', country: 'IN', coordinates: { lat: 20.5937, lng: 78.9629 } }\n    ];\n    \n    electricityZones.forEach(zone => {\n      const boundary: GeographicBoundary = {\n        id: zone.id,\n        name: zone.name,\n        type: 'region',\n        coordinates: zone.coordinates,\n        bounds: {\n          north: zone.coordinates.lat + 5,\n          south: zone.coordinates.lat - 5,\n          east: zone.coordinates.lng + 5,\n          west: zone.coordinates.lng - 5\n        },\n        emissionZone: zone.id\n      };\n      \n      this.boundaries.set(zone.id, boundary);\n    });\n  }\n\n  private loadUSFallbackMappings(): void {\n    const usStates = [\n      { code: 'CA', region: 'CAMX', zips: ['90000-96199'] },\n      { code: 'TX', region: 'ERCT', zips: ['75000-79999', '73000-73999', '88000-88999'] },\n      { code: 'NY', region: 'NYCW', zips: ['10000-14999'] },\n      { code: 'FL', region: 'FRCC', zips: ['32000-34999'] },\n      { code: 'IL', region: 'SRMW', zips: ['60000-62999'] },\n      { code: 'PA', region: 'RFCE', zips: ['15000-19699'] },\n      { code: 'OH', region: 'RFCW', zips: ['43000-45999'] },\n      { code: 'WA', region: 'NWPP', zips: ['98000-99499'] },\n      { code: 'OR', region: 'NWPP', zips: ['97000-97999'] }\n    ];\n    \n    usStates.forEach(state => {\n      state.zips.forEach(range => {\n        const [start, end] = range.split('-').map(z => parseInt(z));\n        for (let zip = start; zip <= end; zip += 100) {\n          const zipCode = zip.toString().padStart(5, '0');\n          const normalizedCode = this.normalizePostalCode(zipCode, 'US');\n          \n          const mapping: PostalCodeMapping = {\n            postalCode: zipCode,\n            normalizedCode,\n            country: 'US',\n            region: state.code,\n            state: state.code,\n            eGridSubregion: state.region,\n            electricityZone: `US-${state.code}`,\n            lastUpdated: new Date().toISOString()\n          };\n          \n          this.postalMappings.set(normalizedCode, mapping);\n        }\n      });\n    });\n    \n    this.updateCountryMappings('US', Array.from(this.postalMappings.keys()).filter(k => \n      this.postalMappings.get(k)?.country === 'US'\n    ));\n  }\n\n  private loadFallbackMappings(): void {\n    logger.info('Loading fallback geographic mappings');\n    \n    this.loadUSFallbackMappings();\n    \n    const fallbackCountries = [\n      { code: 'CA', zone: 'CA' },\n      { code: 'GB', zone: 'GB' },\n      { code: 'DE', zone: 'DE' },\n      { code: 'FR', zone: 'FR' },\n      { code: 'JP', zone: 'JP' },\n      { code: 'AU', zone: 'AU' },\n      { code: 'CN', zone: 'CN' },\n      { code: 'IN', zone: 'IN' }\n    ];\n    \n    fallbackCountries.forEach(country => {\n      const mapping: PostalCodeMapping = {\n        postalCode: '00000',\n        normalizedCode: '00000',\n        country: country.code,\n        region: country.code,\n        electricityZone: country.zone,\n        lastUpdated: new Date().toISOString()\n      };\n      \n      this.postalMappings.set(`${country.code}_00000`, mapping);\n      this.updateCountryMappings(country.code, [`${country.code}_00000`]);\n    });\n  }\n\n  private updateCountryMappings(countryCode: string, postalCodes: string[]): void {\n    const existing = this.countryMappings.get(countryCode) || [];\n    this.countryMappings.set(countryCode, [...existing, ...postalCodes]);\n  }\n\n  private async generateStatistics(): Promise<void> {\n    const totalMappings = this.postalMappings.size;\n    const countries = this.countryMappings.size;\n    \n    let complete = 0;\n    let partial = 0;\n    let missing = 0;\n    \n    this.postalMappings.forEach(mapping => {\n      const hasCoordinates = !!mapping.coordinates;\n      const hasTimezone = !!mapping.timezone;\n      const hasRegion = !!mapping.region;\n      \n      const completeness = [hasCoordinates, hasTimezone, hasRegion].filter(Boolean).length;\n      \n      if (completeness === 3) complete++;\n      else if (completeness >= 1) partial++;\n      else missing++;\n    });\n    \n    this.statistics = {\n      totalMappings,\n      countriesSupported: countries,\n      lastUpdate: new Date().toISOString(),\n      coveragePercentage: Math.round((totalMappings / 1000000) * 100),\n      dataQuality: {\n        complete,\n        partial,\n        missing\n      }\n    };\n  }\n\n  private async cacheAllMappings(): Promise<void> {\n    const cacheData = {\n      postalMappings: Object.fromEntries(this.postalMappings),\n      boundaries: Object.fromEntries(this.boundaries),\n      countryMappings: Object.fromEntries(this.countryMappings),\n      statistics: this.statistics,\n      lastUpdate: new Date().toISOString()\n    };\n    \n    await this.cache.set('geographic_mappings', cacheData, \n      { ttl: 7 * 24 * 60 * 60 * 1000 }\n    );\n  }\n\n  private initializeUpdateScheduler(): void {\n    cron.schedule('0 2 * * 0', async () => {\n      logger.info('Starting weekly geographic mapping update');\n      await this.loadAllMappings();\n    });\n    \n    logger.info('Geographic mapping update scheduler initialized');\n  }\n\n  public getPostalCodeMapping(postalCode: string, countryCode?: string): PostalCodeMapping | null {\n    if (!postalCode) return null;\n    \n    const normalizedCode = countryCode ? \n      this.normalizePostalCode(postalCode, countryCode) : \n      postalCode.replace(/\\s+/g, '').replace(/-/g, '').toUpperCase();\n    \n    let mapping = this.postalMappings.get(normalizedCode);\n    \n    if (!mapping && countryCode) {\n      mapping = this.postalMappings.get(`${countryCode}_${normalizedCode}`);\n    }\n    \n    if (!mapping) {\n      mapping = this.findNearestMapping(normalizedCode, countryCode);\n    }\n    \n    return mapping;\n  }\n\n  private findNearestMapping(postalCode: string, countryCode?: string): PostalCodeMapping | null {\n    if (!countryCode) return null;\n    \n    const countryMappings = this.countryMappings.get(countryCode);\n    if (!countryMappings || countryMappings.length === 0) return null;\n    \n    let nearestMapping: PostalCodeMapping | null = null;\n    let smallestDistance = Infinity;\n    \n    for (const mappingKey of countryMappings) {\n      const mapping = this.postalMappings.get(mappingKey);\n      if (!mapping) continue;\n      \n      const distance = this.calculatePostalDistance(postalCode, mapping.normalizedCode);\n      if (distance < smallestDistance) {\n        smallestDistance = distance;\n        nearestMapping = mapping;\n      }\n    }\n    \n    if (nearestMapping && smallestDistance <= 1000) {\n      logger.debug('Using nearest postal code mapping', {\n        requested: postalCode,\n        nearest: nearestMapping.postalCode,\n        distance: smallestDistance,\n        country: countryCode\n      });\n      return nearestMapping;\n    }\n    \n    return null;\n  }\n\n  private calculatePostalDistance(postal1: string, postal2: string): number {\n    const num1 = parseInt(postal1.replace(/[^0-9]/g, '')) || 0;\n    const num2 = parseInt(postal2.replace(/[^0-9]/g, '')) || 0;\n    return Math.abs(num1 - num2);\n  }\n\n  public getElectricityZone(postalCode: string, countryCode?: string): string | null {\n    const mapping = this.getPostalCodeMapping(postalCode, countryCode);\n    return mapping?.electricityZone || null;\n  }\n\n  public getEGridSubregion(postalCode: string): string | null {\n    const mapping = this.getPostalCodeMapping(postalCode, 'US');\n    return mapping?.eGridSubregion || null;\n  }\n\n  public getSupportedCountries(): string[] {\n    return Array.from(this.countryMappings.keys());\n  }\n\n  public getCountryStatistics(countryCode: string): {\n    mappingCount: number;\n    regions: string[];\n    zones: string[];\n  } {\n    const countryMappings = this.countryMappings.get(countryCode) || [];\n    const mappings = countryMappings\n      .map(key => this.postalMappings.get(key))\n      .filter(Boolean) as PostalCodeMapping[];\n    \n    const regions = [...new Set(mappings.map(m => m.region).filter(Boolean))];\n    const zones = [...new Set(mappings.map(m => m.electricityZone).filter(Boolean))];\n    \n    return {\n      mappingCount: mappings.length,\n      regions,\n      zones\n    };\n  }\n\n  public getStatistics(): MappingStatistics {\n    return { ...this.statistics };\n  }\n\n  public async validateGeographicBoundaries(): Promise<{\n    isValid: boolean;\n    errors: string[];\n    warnings: string[];\n  }> {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    \n    if (this.postalMappings.size === 0) {\n      errors.push('No postal code mappings available');\n    }\n    \n    if (this.boundaries.size === 0) {\n      warnings.push('No geographic boundaries defined');\n    }\n    \n    const countriesWithoutMappings = ['US', 'CA', 'GB', 'DE', 'FR'].filter(\n      country => !this.countryMappings.has(country)\n    );\n    \n    if (countriesWithoutMappings.length > 0) {\n      warnings.push(`Missing mappings for countries: ${countriesWithoutMappings.join(', ')}`);\n    }\n    \n    const dataAge = Date.now() - new Date(this.statistics.lastUpdate).getTime();\n    const maxAge = 30 * 24 * 60 * 60 * 1000; // 30 days\n    \n    if (dataAge > maxAge) {\n      warnings.push(`Geographic data is ${Math.floor(dataAge / (24 * 60 * 60 * 1000))} days old`);\n    }\n    \n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  public async refreshMappings(): Promise<void> {\n    logger.info('Manually refreshing geographic mappings');\n    await this.loadAllMappings();\n  }\n}\n\nexport const geographicMappingService = new GeographicMappingService();\nexport { GeographicMappingService };